(global) PRIVATE DIR *fdir
(global) char findpattern[128]
(global) char findbase[128]

Quiero que FS_FindFirst encuentre el primer archivo que cumpla con ciertas características, dentro de un path. Las características deseadas se van a dar como parte del string que contiene el path. Nótese que glob devuelve una lista con todos los archivos que cumplen el criterio que se le de y la cuenta de los mismos, permitiéndome resolver el problema en pocas líneas. FS_FindNext tiene que encontrar el siguiente archivo en la lista que cumpla el criterio. Es cuestión de llevar un contador de alguna forma (no puedo simplemente omitirlo por compatibilidad con Windows). Una forma fácil sería usar un entero global de tamaño apropiado;
tendría que recordar llevarlo a cero cuando uso FS_FindClose. Sin embargo, tengo que pensar una forma de evitar el uso de globales. Por compatibilidad con la versión de Windows, no puedo agregar argumentos o modificar la función que lo llama para llevar el conteo. Otra opción sería romper la compatibilidad en ese punto, mantener la actual en uno de los archivos de Windows y una copia modificada en los archivos de *NIX. Esta parece la solución más razonable, permitiría simplificar cuatro funciones (FS_FindFirst, FS_FindNext, FS_AddCompressed y FS_FindClose), usando métodos específicos SIMPLES de cada plataforma. -- Nope, no se puede, los usan FS_ExecAutoexec, FS_ListFiles, etc -- Vuelvo al plan original con la variable global.

FS_CreateDirectory (const char *dirname)

Devuelve 1 si puede crear el directorio o si la causa de que no pueda es que ya existe, 0 en otro caso.

FS_ChangeCurrentDirectory (const char *path)

Devuelve 1 si puede cambiar de directorio, 0 si no.

CompareAttributes (const char *path, W32 musthave, W32 canthave)

Difícil de analizar.

FS_FindFirst (const char *path, W32 musthave, W32 canthave)

struct dirent *d
    char *p


    Revisa que la función se haya cerrado la última vez que se usó, chequeando que fdir sea nulo. En caso negativo, avisa via consola de debug y sale.

Copia a findpattern el nombre de archivo del path que se le pasó (lo que haya después del último separador).

Aplica FS_getPath con path como string de entrada y findbase como string de salida.

Si findbase está vacío, revisa que pueda abrir el directorio de trabajo. Si puede, lo asigna a fdir, si no, sale mandando NULL;
si findbase no es un string vacío, trata de abrirlo. Si puede, lo asigna a fdir, si no, sale con NULL.

Mientras pueda leer el directorio en fdir, lo asigna a d y:
1_ Si findpattern está vacío o glob_match evaluando encuentra que el patrón coincide con el nombre de algún archivo:
1. Si findbase está vacío, copia el nombre del archivo a findpath, si no, almacena findbase y el nombre del archivo con formato string / string en findpath. Evidentemente es solo una cuestión de implementación, pero el objetivo es el mismo.
2. Compara los atributos que debe y no debe tener con los que de hecho tiene el archivo en findpath. Si son correctos, devuelve findpath, si no, reevalúa la condición de bucle.


Si sale del bucle, devuelve NULL.



FS_FindNext (W32 musthave, W32 canthave)

struct dirent *d

    Si fdir no apunta a ningún lado, devuelve nulo.
    Mientras pueda leer archivos en el directorio fdir, asigna la estructura del archivo a d y:
    1_ Si el patrón está vacío o coincide con el nombre del archivo en d:
    1. Si findbase está vacío, copia el nombre de d a findpath, si no, copia con formato findbase / "nombre del archivo en d".
    2. Compara los atributos con los que tiene que tener, si los cumple devuelve findpath, si no, reevalúa el bucle.

    Si el bucle termina, devuelve NULL.


FS_DeleteFile (const char *filename)

Devuelve 1 si puede borrar el archivo, 0 si no.


